# Обзор проекта MediaGenerator

## Описание

MediaGenerator - это система для автоматизированного сбора сообщений из Telegram каналов, их модерации через Telegram группу редакторов и создания саммари для публикации в целевой канал. Система состоит из трех микросервисов, работающих совместно для обеспечения полного цикла обработки контента.

## Цель проекта

Автоматизация процесса:
1. Мониторинга множественных Telegram каналов
2. Сбора сообщений и отправки их на модерацию в Telegram группу
3. Обработки решений редакторов (одобрение/отклонение)
4. Создания саммари из одобренных сообщений
5. Публикации саммари в целевой канал

## Основные принципы

- **Микросервисная архитектура** - каждый сервис выполняет свою задачу
- **Файловая система** - простое и надежное хранение данных
- **Telegram-based модерация** - модерация через Telegram группу с inline кнопками
- **Асинхронная обработка** - высокая производительность
- **Модульность** - легкое расширение функционала

## Архитектура системы

### Микросервисная архитектура
Система построена на принципах микросервисов с четким разделением ответственности:

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   COLLECTOR     │───▶│   ASSISTANT     │───▶│    Agregator    │
│   (Сбор)        │    │   (Редактура)   │    │   (Публикация)  │
│   Port: 8001    │    │   Port: 8003    │    │   Port: 8002    │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                    ФАЙЛОВАЯ СИСТЕМА                             │
│             /data/pending/  │  /data/approved/                  │
└─────────────────────────────────────────────────────────────────┘
```

### Сервисы

1. **Collector Service** (Порт 8001)
   - Мониторинг Telegram каналов
   - Сбор новых сообщений
   - Сохранение в папку pending
   - Отправка сообщений с кнопками Ok/Cancel в Telegram группу редакторов

2. **Assistant Service** (Порт 8003)
   - Получение callback от редакторов из Telegram группы
   - Перемещение файлов сообщений в approved или удаление при отказе
   - Обработка решений модерации

3. **Aggregator Service** (Порт 8002)
   - Создание саммари из одобренных сообщений
   - Публикация саммари в целевой канал
   - Удаление файлов после создания саммари

## Технологический стек

### Backend
- **Python 3.11** - основной язык программирования
- **FastAPI** - веб-фреймворк для REST API
- **Uvicorn** - ASGI сервер
- **Pydantic** - валидация данных
- **Telethon** - работа с Telegram API
- **aiogram** - Telegram Bot API

### Инфраструктура
- **Docker** - контейнеризация
- **Docker Compose** - оркестрация сервисов
- **Файловая система** - хранение данных (JSON файлы)

### Мониторинг и логирование
- **Встроенное логирование** Python
- **Health checks** для каждого сервиса
- **Метрики** производительности

## Структура данных

### Формат сообщения
```json
{
  "id": "unique_message_id",
  "channel_id": "telegram_channel_id",
  "channel_name": "channel_username",
  "message_id": 12345,
  "text": "Текст сообщения",
  "media": {
    "type": "photo|video|document",
    "file_id": "telegram_file_id",
    "caption": "Подпись к медиа"
  },
  "author": {
    "id": "author_id",
    "username": "author_username",
    "first_name": "Имя",
    "last_name": "Фамилия"
  },
  "timestamp": "2024-01-01T12:00:00Z",
  "metadata": {
    "views": 1000,
    "forwards": 50,
    "reactions": {...}
  },
  "status": "pending|approved|rejected",
  "moderation": {
    "moderator_id": "moderator_id",
    "timestamp": "2024-01-01T12:30:00Z",
    "reason": "Причина решения"
  }
}
```

## Файловая структура хранения

```
/data/
├── pending/          # Новые сообщения для модерации
│   ├── message_1.json
│   ├── message_2.json
│   └── ...
├── approved/         # Одобренные сообщения
│   ├── message_3.json
│   └── ...
└── sessions/        # Telegram сессии
    ├── mtproto.session
    └── temp_auth.session
```

## Поток данных

```
Telegram Каналы → Collector → pending/ → Telegram Группа Модерации → Человек-редактор принимает решение → Assistant → approved/ → Aggregator → Саммари → Целевой Канал
```

### Детальный процесс

1. **Сбор** (Collector Service)
   - Подключение к Telegram API через Telethon
   - Мониторинг указанных каналов
   - Получение новых сообщений
   - Сохранение в JSON формате в папку `pending/`
   - Отправка сообщения в Telegram группу редакторов с кнопками Ok/Cancel

2. **Модерация** (Assistant Service)
   - Получение callback от inline кнопок в Telegram группе
   - При нажатии "Ok": перемещение файла из `pending/` в `approved/`
   - При нажатии "Cancel": удаление файла из `pending/`

3. **Создание саммари** (Aggregator Service)
   - В установленное время проверка папки `approved/` 
   - Сбор одобренных сообщений
   - Создание саммари из накопленного контента
   - Публикация саммари в целевой канал
   - Удаление обработанных файлов

## Основные функции

### 1. Мониторинг каналов
- Подключение к Telegram API через Telethon
- Отслеживание новых сообщений в реальном времени
- Фильтрация по типу контента
- Автоматическое сохранение метаданных

### 2. Модерация контента
- Ручная модерация через Telegram группу с inline кнопками
- Система статусов через перемещение файлов сообщений(pending/approved)

### 3. Публикация контента
- Автоматическое создание саммари из одобренного контента
- Публикация в целевой канал

## Конфигурация

### Переменные окружения
```env
# Telegram API
API_ID=your_api_id
API_HASH=your_api_hash
PHONE_NUMBER=your_phone_number
BOT_TOKEN=your_bot_token

# Сервисы
COLLECTOR_HOST=0.0.0.0
COLLECTOR_PORT=8001
AGGREGATOR_HOST=0.0.0.0
AGGREGATOR_PORT=8002
ASSISTANT_HOST=0.0.0.0
ASSISTANT_PORT=8003

# Мониторинг
MONITORING_CHANNELS=@channel1,@channel2
BATCH_SIZE=10
```

## Развертывание

### Требования
- Docker 20.10+
- Docker Compose 2.0+

## Безопасность

### Аутентификация
- Telegram API ключи
- Сессии пользователей
- Токены ботов

### Хранение данных
- Локальная файловая система
- Шифрование сессий Telegram
- Ротация логов

### Сетевая безопасность
- Внутренняя сеть Docker
- Ограничение портов
- HTTPS для продакшена

## Мониторинг и отладка

### Health Checks
Каждый сервис предоставляет endpoint `/health` для проверки состояния.

### Логирование
- Структурированные логи в JSON формате
- Различные уровни логирования (DEBUG, INFO, WARNING, ERROR)
- Ротация логов по размеру и времени

## Расширение системы

### Добавление новых сервисов
1. Создать новый микросервис
2. Добавить в docker-compose.yml
3. Настроить взаимодействие через API
4. Обновить документацию

## Поддержка и обслуживание

### Резервное копирование
- Автоматическое резервное копирование данных
- Экспорт конфигураций
- Восстановление из бэкапов

### Обновления
- Версионирование API
- Миграции данных
- Откат изменений

## Операционная документация: запуск, проверки и отладка (из контейнера)

Ниже приведены практические инструкции, как проверить работоспособность сервисов непосредственно из контейнера (Docker/Coolify), как провести первичную авторизацию Telethon, и как диагностировать типичные проблемы.

### Общие принципы
- Оба сервиса используют общий путь данных внутри контейнера: `/app/data` (можно переопределить переменной `DATA_DIR`).
- Структура каталога данных:
  - `/app/data/pending` — новые сообщения
  - `/app/data/approved` — одобренные
  - `/app/data/sessions` — сессия Telethon (файл `mtproto.session`)
- На PaaS (например, Coolify) прикрепите один и тот же Persistent Storage к обоим приложениям по пути `/app/data`.

### Переменные окружения (минимально необходимые)
- Общие: `DATA_DIR=/app/data`
- Collector: `API_ID`, `API_HASH`, (на первичную авторизацию — `PHONE_NUMBER` или `PHONE`), `MONITORING_CHANNELS` (либо файл `/app/data/channels.txt`)
- Assistant: `BOT_TOKEN` (обязательно), для Collector — `EDITORS_CHANNEL_ID` (целевой чат редакторов)

---

### Проверка каталога данных из контейнера
- Убедитесь, что контейнер видит и может писать в `/app/data`:
  - Проверка наличия: `ls -la /app/data`
  - Создание подпапок (если пустой том): `mkdir -p /app/data/pending /app/data/approved /app/data/sessions`

---

### Проверка Collector (внутри контейнера)
1) Health-check (локально в контейнере):
   - `curl -s http://127.0.0.1:8001/health` — в ответе `data_dirs` должны указывать на `/app/data/...`, `status` — `ok` при авторизованной сессии.
2) Авторизация Telethon (разово):
   - Убедитесь, что заданы `API_ID`, `API_HASH`, `PHONE_NUMBER` и (рекомендуется) `DATA_DIR=/app/data`.
   - При необходимости форсируйте SMS: установите `FORCE_SMS=1`.
   - Запустите: `python -m app.collector.auth_login`.
   - При включённой 2FA будет дополнительный запрос пароля.
   - После успеха появится `/app/data/sessions/mtproto.session`.
3) Проверка мониторинга:
   - В health: поле `authorized` должно быть `true`.
   - При появлении новых сообщений в отслеживаемых каналах файлы должны записываться в `/app/data/pending`.

---

### Проверка Assistant (внутри контейнера)
1) Health-check:
   - `curl -s http://127.0.0.1:8003/health` — проверяем пути `pending`/`approved` и статус `ok`.
2) Тест webhook вручную:
   - Отправьте тестовый callback-запрос (замените `FILENAME.json` на существующий файл в `pending` и укажите корректный `chat_id`):
```
POST /telegram/webhook
Content-Type: application/json

{
  "callback_query": {
    "id": "1",
    "message": {"message_id": 123, "chat": {"id": 123456789}},
    "data": "approve:FILENAME.json"
  }
}
```
   - Ожидаем перемещение файла из `pending` в `approved`.

---

### Авторизация Telethon: рекомендации
- Предпочтительно выполнить авторизацию локально и загрузить готовый файл сессии в `/app/data/sessions/mtproto.session` на PaaS — так вы избежите интерактивных шагов в облаке.
- Если делаете авторизацию в контейнере:
  - Установите `FORCE_SMS=1`, если код в приложении не приходит.
  - Следите за сообщениями `FLOOD_WAIT` (превышен лимит попыток) — подождите указанное время.
  - При включённой 2FA будет запрос пароля — подготовьте его заранее.

---

### Типичные проблемы и решения (Troubleshooting)
1) Код подтверждения не приходит при авторизации внутри контейнера:
   - По умолчанию Telegram отправляет код в чат «Telegram» в вашем приложении (не SMS). Проверьте этот чат в клиенте Telegram (мобильном/десктопном).
   - Включите отправку SMS: установите `FORCE_SMS=1` и повторите `python -m app.collector.auth_login`.
   - Возможен лимит попыток (FLOOD_WAIT) — дождитесь указанного таймаута.
   - Убедитесь, что номер в международном формате и соответствует аккаунту.
   - Проверьте сетевую доступность Telegram из окружения PaaS (файрвол, egress-политики). При проблемах авторизуйтесь локально и перенесите файл сессии.
2) Ошибка sqlite3 «unable to open database file»:
   - Причина: отсутствует каталог `/app/data/sessions` в смонтированном томе.
   - Решение: создайте каталог и убедитесь в правах записи; повторите запуск. В коде сервисов каталоги создаются автоматически при старте, но если том пустой, убедитесь, что у пользователя контейнера есть права на запись.
3) Файлы не появляются/не перемещаются:
   - Проверьте переменную `DATA_DIR` и что оба сервиса используют один и тот же персистентный том в `/app/data`.
   - Проверьте логи сервисов и ответы `/health`.

---

### Чек-лист быстрой диагностики
- /app/data смонтирован и доступен для записи
- В collector `/health` показывает `authorized=true`
- В assistant `/health` показывает корректные пути
- Для авторизации использован `FORCE_SMS=1` (при необходимости)
- Файлы в `/app/data/pending` создаются (collector), и перемещаются в `/app/data/approved` (assistant)